// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"github.com/yoshiso/hypersync/ent/migrate"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"github.com/yoshiso/hypersync/ent/fill"
	"github.com/yoshiso/hypersync/ent/funding"
	"github.com/yoshiso/hypersync/ent/rewardsclaim"
	"github.com/yoshiso/hypersync/ent/spotgenesis"
	"github.com/yoshiso/hypersync/ent/vaultdelta"
	"github.com/yoshiso/hypersync/ent/vaultleadercommission"
	"github.com/yoshiso/hypersync/ent/vaultwithdrawal"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Fill is the client for interacting with the Fill builders.
	Fill *FillClient
	// Funding is the client for interacting with the Funding builders.
	Funding *FundingClient
	// RewardsClaim is the client for interacting with the RewardsClaim builders.
	RewardsClaim *RewardsClaimClient
	// SpotGenesis is the client for interacting with the SpotGenesis builders.
	SpotGenesis *SpotGenesisClient
	// VaultDelta is the client for interacting with the VaultDelta builders.
	VaultDelta *VaultDeltaClient
	// VaultLeaderCommission is the client for interacting with the VaultLeaderCommission builders.
	VaultLeaderCommission *VaultLeaderCommissionClient
	// VaultWithdrawal is the client for interacting with the VaultWithdrawal builders.
	VaultWithdrawal *VaultWithdrawalClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Fill = NewFillClient(c.config)
	c.Funding = NewFundingClient(c.config)
	c.RewardsClaim = NewRewardsClaimClient(c.config)
	c.SpotGenesis = NewSpotGenesisClient(c.config)
	c.VaultDelta = NewVaultDeltaClient(c.config)
	c.VaultLeaderCommission = NewVaultLeaderCommissionClient(c.config)
	c.VaultWithdrawal = NewVaultWithdrawalClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                   ctx,
		config:                cfg,
		Fill:                  NewFillClient(cfg),
		Funding:               NewFundingClient(cfg),
		RewardsClaim:          NewRewardsClaimClient(cfg),
		SpotGenesis:           NewSpotGenesisClient(cfg),
		VaultDelta:            NewVaultDeltaClient(cfg),
		VaultLeaderCommission: NewVaultLeaderCommissionClient(cfg),
		VaultWithdrawal:       NewVaultWithdrawalClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                   ctx,
		config:                cfg,
		Fill:                  NewFillClient(cfg),
		Funding:               NewFundingClient(cfg),
		RewardsClaim:          NewRewardsClaimClient(cfg),
		SpotGenesis:           NewSpotGenesisClient(cfg),
		VaultDelta:            NewVaultDeltaClient(cfg),
		VaultLeaderCommission: NewVaultLeaderCommissionClient(cfg),
		VaultWithdrawal:       NewVaultWithdrawalClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Fill.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.Fill, c.Funding, c.RewardsClaim, c.SpotGenesis, c.VaultDelta,
		c.VaultLeaderCommission, c.VaultWithdrawal,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.Fill, c.Funding, c.RewardsClaim, c.SpotGenesis, c.VaultDelta,
		c.VaultLeaderCommission, c.VaultWithdrawal,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *FillMutation:
		return c.Fill.mutate(ctx, m)
	case *FundingMutation:
		return c.Funding.mutate(ctx, m)
	case *RewardsClaimMutation:
		return c.RewardsClaim.mutate(ctx, m)
	case *SpotGenesisMutation:
		return c.SpotGenesis.mutate(ctx, m)
	case *VaultDeltaMutation:
		return c.VaultDelta.mutate(ctx, m)
	case *VaultLeaderCommissionMutation:
		return c.VaultLeaderCommission.mutate(ctx, m)
	case *VaultWithdrawalMutation:
		return c.VaultWithdrawal.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// FillClient is a client for the Fill schema.
type FillClient struct {
	config
}

// NewFillClient returns a client for the Fill from the given config.
func NewFillClient(c config) *FillClient {
	return &FillClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `fill.Hooks(f(g(h())))`.
func (c *FillClient) Use(hooks ...Hook) {
	c.hooks.Fill = append(c.hooks.Fill, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `fill.Intercept(f(g(h())))`.
func (c *FillClient) Intercept(interceptors ...Interceptor) {
	c.inters.Fill = append(c.inters.Fill, interceptors...)
}

// Create returns a builder for creating a Fill entity.
func (c *FillClient) Create() *FillCreate {
	mutation := newFillMutation(c.config, OpCreate)
	return &FillCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Fill entities.
func (c *FillClient) CreateBulk(builders ...*FillCreate) *FillCreateBulk {
	return &FillCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FillClient) MapCreateBulk(slice any, setFunc func(*FillCreate, int)) *FillCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FillCreateBulk{err: fmt.Errorf("calling to FillClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FillCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FillCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Fill.
func (c *FillClient) Update() *FillUpdate {
	mutation := newFillMutation(c.config, OpUpdate)
	return &FillUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FillClient) UpdateOne(f *Fill) *FillUpdateOne {
	mutation := newFillMutation(c.config, OpUpdateOne, withFill(f))
	return &FillUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FillClient) UpdateOneID(id int) *FillUpdateOne {
	mutation := newFillMutation(c.config, OpUpdateOne, withFillID(id))
	return &FillUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Fill.
func (c *FillClient) Delete() *FillDelete {
	mutation := newFillMutation(c.config, OpDelete)
	return &FillDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FillClient) DeleteOne(f *Fill) *FillDeleteOne {
	return c.DeleteOneID(f.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FillClient) DeleteOneID(id int) *FillDeleteOne {
	builder := c.Delete().Where(fill.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FillDeleteOne{builder}
}

// Query returns a query builder for Fill.
func (c *FillClient) Query() *FillQuery {
	return &FillQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFill},
		inters: c.Interceptors(),
	}
}

// Get returns a Fill entity by its id.
func (c *FillClient) Get(ctx context.Context, id int) (*Fill, error) {
	return c.Query().Where(fill.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FillClient) GetX(ctx context.Context, id int) *Fill {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *FillClient) Hooks() []Hook {
	return c.hooks.Fill
}

// Interceptors returns the client interceptors.
func (c *FillClient) Interceptors() []Interceptor {
	return c.inters.Fill
}

func (c *FillClient) mutate(ctx context.Context, m *FillMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FillCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FillUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FillUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FillDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Fill mutation op: %q", m.Op())
	}
}

// FundingClient is a client for the Funding schema.
type FundingClient struct {
	config
}

// NewFundingClient returns a client for the Funding from the given config.
func NewFundingClient(c config) *FundingClient {
	return &FundingClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `funding.Hooks(f(g(h())))`.
func (c *FundingClient) Use(hooks ...Hook) {
	c.hooks.Funding = append(c.hooks.Funding, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `funding.Intercept(f(g(h())))`.
func (c *FundingClient) Intercept(interceptors ...Interceptor) {
	c.inters.Funding = append(c.inters.Funding, interceptors...)
}

// Create returns a builder for creating a Funding entity.
func (c *FundingClient) Create() *FundingCreate {
	mutation := newFundingMutation(c.config, OpCreate)
	return &FundingCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Funding entities.
func (c *FundingClient) CreateBulk(builders ...*FundingCreate) *FundingCreateBulk {
	return &FundingCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FundingClient) MapCreateBulk(slice any, setFunc func(*FundingCreate, int)) *FundingCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FundingCreateBulk{err: fmt.Errorf("calling to FundingClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FundingCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FundingCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Funding.
func (c *FundingClient) Update() *FundingUpdate {
	mutation := newFundingMutation(c.config, OpUpdate)
	return &FundingUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FundingClient) UpdateOne(f *Funding) *FundingUpdateOne {
	mutation := newFundingMutation(c.config, OpUpdateOne, withFunding(f))
	return &FundingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FundingClient) UpdateOneID(id int) *FundingUpdateOne {
	mutation := newFundingMutation(c.config, OpUpdateOne, withFundingID(id))
	return &FundingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Funding.
func (c *FundingClient) Delete() *FundingDelete {
	mutation := newFundingMutation(c.config, OpDelete)
	return &FundingDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FundingClient) DeleteOne(f *Funding) *FundingDeleteOne {
	return c.DeleteOneID(f.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FundingClient) DeleteOneID(id int) *FundingDeleteOne {
	builder := c.Delete().Where(funding.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FundingDeleteOne{builder}
}

// Query returns a query builder for Funding.
func (c *FundingClient) Query() *FundingQuery {
	return &FundingQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFunding},
		inters: c.Interceptors(),
	}
}

// Get returns a Funding entity by its id.
func (c *FundingClient) Get(ctx context.Context, id int) (*Funding, error) {
	return c.Query().Where(funding.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FundingClient) GetX(ctx context.Context, id int) *Funding {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *FundingClient) Hooks() []Hook {
	return c.hooks.Funding
}

// Interceptors returns the client interceptors.
func (c *FundingClient) Interceptors() []Interceptor {
	return c.inters.Funding
}

func (c *FundingClient) mutate(ctx context.Context, m *FundingMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FundingCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FundingUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FundingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FundingDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Funding mutation op: %q", m.Op())
	}
}

// RewardsClaimClient is a client for the RewardsClaim schema.
type RewardsClaimClient struct {
	config
}

// NewRewardsClaimClient returns a client for the RewardsClaim from the given config.
func NewRewardsClaimClient(c config) *RewardsClaimClient {
	return &RewardsClaimClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `rewardsclaim.Hooks(f(g(h())))`.
func (c *RewardsClaimClient) Use(hooks ...Hook) {
	c.hooks.RewardsClaim = append(c.hooks.RewardsClaim, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `rewardsclaim.Intercept(f(g(h())))`.
func (c *RewardsClaimClient) Intercept(interceptors ...Interceptor) {
	c.inters.RewardsClaim = append(c.inters.RewardsClaim, interceptors...)
}

// Create returns a builder for creating a RewardsClaim entity.
func (c *RewardsClaimClient) Create() *RewardsClaimCreate {
	mutation := newRewardsClaimMutation(c.config, OpCreate)
	return &RewardsClaimCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of RewardsClaim entities.
func (c *RewardsClaimClient) CreateBulk(builders ...*RewardsClaimCreate) *RewardsClaimCreateBulk {
	return &RewardsClaimCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RewardsClaimClient) MapCreateBulk(slice any, setFunc func(*RewardsClaimCreate, int)) *RewardsClaimCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RewardsClaimCreateBulk{err: fmt.Errorf("calling to RewardsClaimClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RewardsClaimCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RewardsClaimCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for RewardsClaim.
func (c *RewardsClaimClient) Update() *RewardsClaimUpdate {
	mutation := newRewardsClaimMutation(c.config, OpUpdate)
	return &RewardsClaimUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RewardsClaimClient) UpdateOne(rc *RewardsClaim) *RewardsClaimUpdateOne {
	mutation := newRewardsClaimMutation(c.config, OpUpdateOne, withRewardsClaim(rc))
	return &RewardsClaimUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RewardsClaimClient) UpdateOneID(id int) *RewardsClaimUpdateOne {
	mutation := newRewardsClaimMutation(c.config, OpUpdateOne, withRewardsClaimID(id))
	return &RewardsClaimUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for RewardsClaim.
func (c *RewardsClaimClient) Delete() *RewardsClaimDelete {
	mutation := newRewardsClaimMutation(c.config, OpDelete)
	return &RewardsClaimDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RewardsClaimClient) DeleteOne(rc *RewardsClaim) *RewardsClaimDeleteOne {
	return c.DeleteOneID(rc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RewardsClaimClient) DeleteOneID(id int) *RewardsClaimDeleteOne {
	builder := c.Delete().Where(rewardsclaim.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RewardsClaimDeleteOne{builder}
}

// Query returns a query builder for RewardsClaim.
func (c *RewardsClaimClient) Query() *RewardsClaimQuery {
	return &RewardsClaimQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRewardsClaim},
		inters: c.Interceptors(),
	}
}

// Get returns a RewardsClaim entity by its id.
func (c *RewardsClaimClient) Get(ctx context.Context, id int) (*RewardsClaim, error) {
	return c.Query().Where(rewardsclaim.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RewardsClaimClient) GetX(ctx context.Context, id int) *RewardsClaim {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *RewardsClaimClient) Hooks() []Hook {
	return c.hooks.RewardsClaim
}

// Interceptors returns the client interceptors.
func (c *RewardsClaimClient) Interceptors() []Interceptor {
	return c.inters.RewardsClaim
}

func (c *RewardsClaimClient) mutate(ctx context.Context, m *RewardsClaimMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RewardsClaimCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RewardsClaimUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RewardsClaimUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RewardsClaimDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown RewardsClaim mutation op: %q", m.Op())
	}
}

// SpotGenesisClient is a client for the SpotGenesis schema.
type SpotGenesisClient struct {
	config
}

// NewSpotGenesisClient returns a client for the SpotGenesis from the given config.
func NewSpotGenesisClient(c config) *SpotGenesisClient {
	return &SpotGenesisClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `spotgenesis.Hooks(f(g(h())))`.
func (c *SpotGenesisClient) Use(hooks ...Hook) {
	c.hooks.SpotGenesis = append(c.hooks.SpotGenesis, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `spotgenesis.Intercept(f(g(h())))`.
func (c *SpotGenesisClient) Intercept(interceptors ...Interceptor) {
	c.inters.SpotGenesis = append(c.inters.SpotGenesis, interceptors...)
}

// Create returns a builder for creating a SpotGenesis entity.
func (c *SpotGenesisClient) Create() *SpotGenesisCreate {
	mutation := newSpotGenesisMutation(c.config, OpCreate)
	return &SpotGenesisCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SpotGenesis entities.
func (c *SpotGenesisClient) CreateBulk(builders ...*SpotGenesisCreate) *SpotGenesisCreateBulk {
	return &SpotGenesisCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SpotGenesisClient) MapCreateBulk(slice any, setFunc func(*SpotGenesisCreate, int)) *SpotGenesisCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SpotGenesisCreateBulk{err: fmt.Errorf("calling to SpotGenesisClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SpotGenesisCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SpotGenesisCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SpotGenesis.
func (c *SpotGenesisClient) Update() *SpotGenesisUpdate {
	mutation := newSpotGenesisMutation(c.config, OpUpdate)
	return &SpotGenesisUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SpotGenesisClient) UpdateOne(sg *SpotGenesis) *SpotGenesisUpdateOne {
	mutation := newSpotGenesisMutation(c.config, OpUpdateOne, withSpotGenesis(sg))
	return &SpotGenesisUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SpotGenesisClient) UpdateOneID(id int) *SpotGenesisUpdateOne {
	mutation := newSpotGenesisMutation(c.config, OpUpdateOne, withSpotGenesisID(id))
	return &SpotGenesisUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SpotGenesis.
func (c *SpotGenesisClient) Delete() *SpotGenesisDelete {
	mutation := newSpotGenesisMutation(c.config, OpDelete)
	return &SpotGenesisDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SpotGenesisClient) DeleteOne(sg *SpotGenesis) *SpotGenesisDeleteOne {
	return c.DeleteOneID(sg.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SpotGenesisClient) DeleteOneID(id int) *SpotGenesisDeleteOne {
	builder := c.Delete().Where(spotgenesis.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SpotGenesisDeleteOne{builder}
}

// Query returns a query builder for SpotGenesis.
func (c *SpotGenesisClient) Query() *SpotGenesisQuery {
	return &SpotGenesisQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSpotGenesis},
		inters: c.Interceptors(),
	}
}

// Get returns a SpotGenesis entity by its id.
func (c *SpotGenesisClient) Get(ctx context.Context, id int) (*SpotGenesis, error) {
	return c.Query().Where(spotgenesis.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SpotGenesisClient) GetX(ctx context.Context, id int) *SpotGenesis {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *SpotGenesisClient) Hooks() []Hook {
	return c.hooks.SpotGenesis
}

// Interceptors returns the client interceptors.
func (c *SpotGenesisClient) Interceptors() []Interceptor {
	return c.inters.SpotGenesis
}

func (c *SpotGenesisClient) mutate(ctx context.Context, m *SpotGenesisMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SpotGenesisCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SpotGenesisUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SpotGenesisUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SpotGenesisDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SpotGenesis mutation op: %q", m.Op())
	}
}

// VaultDeltaClient is a client for the VaultDelta schema.
type VaultDeltaClient struct {
	config
}

// NewVaultDeltaClient returns a client for the VaultDelta from the given config.
func NewVaultDeltaClient(c config) *VaultDeltaClient {
	return &VaultDeltaClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `vaultdelta.Hooks(f(g(h())))`.
func (c *VaultDeltaClient) Use(hooks ...Hook) {
	c.hooks.VaultDelta = append(c.hooks.VaultDelta, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `vaultdelta.Intercept(f(g(h())))`.
func (c *VaultDeltaClient) Intercept(interceptors ...Interceptor) {
	c.inters.VaultDelta = append(c.inters.VaultDelta, interceptors...)
}

// Create returns a builder for creating a VaultDelta entity.
func (c *VaultDeltaClient) Create() *VaultDeltaCreate {
	mutation := newVaultDeltaMutation(c.config, OpCreate)
	return &VaultDeltaCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of VaultDelta entities.
func (c *VaultDeltaClient) CreateBulk(builders ...*VaultDeltaCreate) *VaultDeltaCreateBulk {
	return &VaultDeltaCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *VaultDeltaClient) MapCreateBulk(slice any, setFunc func(*VaultDeltaCreate, int)) *VaultDeltaCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &VaultDeltaCreateBulk{err: fmt.Errorf("calling to VaultDeltaClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*VaultDeltaCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &VaultDeltaCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for VaultDelta.
func (c *VaultDeltaClient) Update() *VaultDeltaUpdate {
	mutation := newVaultDeltaMutation(c.config, OpUpdate)
	return &VaultDeltaUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VaultDeltaClient) UpdateOne(vd *VaultDelta) *VaultDeltaUpdateOne {
	mutation := newVaultDeltaMutation(c.config, OpUpdateOne, withVaultDelta(vd))
	return &VaultDeltaUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *VaultDeltaClient) UpdateOneID(id int) *VaultDeltaUpdateOne {
	mutation := newVaultDeltaMutation(c.config, OpUpdateOne, withVaultDeltaID(id))
	return &VaultDeltaUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for VaultDelta.
func (c *VaultDeltaClient) Delete() *VaultDeltaDelete {
	mutation := newVaultDeltaMutation(c.config, OpDelete)
	return &VaultDeltaDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *VaultDeltaClient) DeleteOne(vd *VaultDelta) *VaultDeltaDeleteOne {
	return c.DeleteOneID(vd.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *VaultDeltaClient) DeleteOneID(id int) *VaultDeltaDeleteOne {
	builder := c.Delete().Where(vaultdelta.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &VaultDeltaDeleteOne{builder}
}

// Query returns a query builder for VaultDelta.
func (c *VaultDeltaClient) Query() *VaultDeltaQuery {
	return &VaultDeltaQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeVaultDelta},
		inters: c.Interceptors(),
	}
}

// Get returns a VaultDelta entity by its id.
func (c *VaultDeltaClient) Get(ctx context.Context, id int) (*VaultDelta, error) {
	return c.Query().Where(vaultdelta.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *VaultDeltaClient) GetX(ctx context.Context, id int) *VaultDelta {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *VaultDeltaClient) Hooks() []Hook {
	return c.hooks.VaultDelta
}

// Interceptors returns the client interceptors.
func (c *VaultDeltaClient) Interceptors() []Interceptor {
	return c.inters.VaultDelta
}

func (c *VaultDeltaClient) mutate(ctx context.Context, m *VaultDeltaMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&VaultDeltaCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&VaultDeltaUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&VaultDeltaUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&VaultDeltaDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown VaultDelta mutation op: %q", m.Op())
	}
}

// VaultLeaderCommissionClient is a client for the VaultLeaderCommission schema.
type VaultLeaderCommissionClient struct {
	config
}

// NewVaultLeaderCommissionClient returns a client for the VaultLeaderCommission from the given config.
func NewVaultLeaderCommissionClient(c config) *VaultLeaderCommissionClient {
	return &VaultLeaderCommissionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `vaultleadercommission.Hooks(f(g(h())))`.
func (c *VaultLeaderCommissionClient) Use(hooks ...Hook) {
	c.hooks.VaultLeaderCommission = append(c.hooks.VaultLeaderCommission, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `vaultleadercommission.Intercept(f(g(h())))`.
func (c *VaultLeaderCommissionClient) Intercept(interceptors ...Interceptor) {
	c.inters.VaultLeaderCommission = append(c.inters.VaultLeaderCommission, interceptors...)
}

// Create returns a builder for creating a VaultLeaderCommission entity.
func (c *VaultLeaderCommissionClient) Create() *VaultLeaderCommissionCreate {
	mutation := newVaultLeaderCommissionMutation(c.config, OpCreate)
	return &VaultLeaderCommissionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of VaultLeaderCommission entities.
func (c *VaultLeaderCommissionClient) CreateBulk(builders ...*VaultLeaderCommissionCreate) *VaultLeaderCommissionCreateBulk {
	return &VaultLeaderCommissionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *VaultLeaderCommissionClient) MapCreateBulk(slice any, setFunc func(*VaultLeaderCommissionCreate, int)) *VaultLeaderCommissionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &VaultLeaderCommissionCreateBulk{err: fmt.Errorf("calling to VaultLeaderCommissionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*VaultLeaderCommissionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &VaultLeaderCommissionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for VaultLeaderCommission.
func (c *VaultLeaderCommissionClient) Update() *VaultLeaderCommissionUpdate {
	mutation := newVaultLeaderCommissionMutation(c.config, OpUpdate)
	return &VaultLeaderCommissionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VaultLeaderCommissionClient) UpdateOne(vlc *VaultLeaderCommission) *VaultLeaderCommissionUpdateOne {
	mutation := newVaultLeaderCommissionMutation(c.config, OpUpdateOne, withVaultLeaderCommission(vlc))
	return &VaultLeaderCommissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *VaultLeaderCommissionClient) UpdateOneID(id int) *VaultLeaderCommissionUpdateOne {
	mutation := newVaultLeaderCommissionMutation(c.config, OpUpdateOne, withVaultLeaderCommissionID(id))
	return &VaultLeaderCommissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for VaultLeaderCommission.
func (c *VaultLeaderCommissionClient) Delete() *VaultLeaderCommissionDelete {
	mutation := newVaultLeaderCommissionMutation(c.config, OpDelete)
	return &VaultLeaderCommissionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *VaultLeaderCommissionClient) DeleteOne(vlc *VaultLeaderCommission) *VaultLeaderCommissionDeleteOne {
	return c.DeleteOneID(vlc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *VaultLeaderCommissionClient) DeleteOneID(id int) *VaultLeaderCommissionDeleteOne {
	builder := c.Delete().Where(vaultleadercommission.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &VaultLeaderCommissionDeleteOne{builder}
}

// Query returns a query builder for VaultLeaderCommission.
func (c *VaultLeaderCommissionClient) Query() *VaultLeaderCommissionQuery {
	return &VaultLeaderCommissionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeVaultLeaderCommission},
		inters: c.Interceptors(),
	}
}

// Get returns a VaultLeaderCommission entity by its id.
func (c *VaultLeaderCommissionClient) Get(ctx context.Context, id int) (*VaultLeaderCommission, error) {
	return c.Query().Where(vaultleadercommission.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *VaultLeaderCommissionClient) GetX(ctx context.Context, id int) *VaultLeaderCommission {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *VaultLeaderCommissionClient) Hooks() []Hook {
	return c.hooks.VaultLeaderCommission
}

// Interceptors returns the client interceptors.
func (c *VaultLeaderCommissionClient) Interceptors() []Interceptor {
	return c.inters.VaultLeaderCommission
}

func (c *VaultLeaderCommissionClient) mutate(ctx context.Context, m *VaultLeaderCommissionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&VaultLeaderCommissionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&VaultLeaderCommissionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&VaultLeaderCommissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&VaultLeaderCommissionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown VaultLeaderCommission mutation op: %q", m.Op())
	}
}

// VaultWithdrawalClient is a client for the VaultWithdrawal schema.
type VaultWithdrawalClient struct {
	config
}

// NewVaultWithdrawalClient returns a client for the VaultWithdrawal from the given config.
func NewVaultWithdrawalClient(c config) *VaultWithdrawalClient {
	return &VaultWithdrawalClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `vaultwithdrawal.Hooks(f(g(h())))`.
func (c *VaultWithdrawalClient) Use(hooks ...Hook) {
	c.hooks.VaultWithdrawal = append(c.hooks.VaultWithdrawal, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `vaultwithdrawal.Intercept(f(g(h())))`.
func (c *VaultWithdrawalClient) Intercept(interceptors ...Interceptor) {
	c.inters.VaultWithdrawal = append(c.inters.VaultWithdrawal, interceptors...)
}

// Create returns a builder for creating a VaultWithdrawal entity.
func (c *VaultWithdrawalClient) Create() *VaultWithdrawalCreate {
	mutation := newVaultWithdrawalMutation(c.config, OpCreate)
	return &VaultWithdrawalCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of VaultWithdrawal entities.
func (c *VaultWithdrawalClient) CreateBulk(builders ...*VaultWithdrawalCreate) *VaultWithdrawalCreateBulk {
	return &VaultWithdrawalCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *VaultWithdrawalClient) MapCreateBulk(slice any, setFunc func(*VaultWithdrawalCreate, int)) *VaultWithdrawalCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &VaultWithdrawalCreateBulk{err: fmt.Errorf("calling to VaultWithdrawalClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*VaultWithdrawalCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &VaultWithdrawalCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for VaultWithdrawal.
func (c *VaultWithdrawalClient) Update() *VaultWithdrawalUpdate {
	mutation := newVaultWithdrawalMutation(c.config, OpUpdate)
	return &VaultWithdrawalUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VaultWithdrawalClient) UpdateOne(vw *VaultWithdrawal) *VaultWithdrawalUpdateOne {
	mutation := newVaultWithdrawalMutation(c.config, OpUpdateOne, withVaultWithdrawal(vw))
	return &VaultWithdrawalUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *VaultWithdrawalClient) UpdateOneID(id int) *VaultWithdrawalUpdateOne {
	mutation := newVaultWithdrawalMutation(c.config, OpUpdateOne, withVaultWithdrawalID(id))
	return &VaultWithdrawalUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for VaultWithdrawal.
func (c *VaultWithdrawalClient) Delete() *VaultWithdrawalDelete {
	mutation := newVaultWithdrawalMutation(c.config, OpDelete)
	return &VaultWithdrawalDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *VaultWithdrawalClient) DeleteOne(vw *VaultWithdrawal) *VaultWithdrawalDeleteOne {
	return c.DeleteOneID(vw.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *VaultWithdrawalClient) DeleteOneID(id int) *VaultWithdrawalDeleteOne {
	builder := c.Delete().Where(vaultwithdrawal.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &VaultWithdrawalDeleteOne{builder}
}

// Query returns a query builder for VaultWithdrawal.
func (c *VaultWithdrawalClient) Query() *VaultWithdrawalQuery {
	return &VaultWithdrawalQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeVaultWithdrawal},
		inters: c.Interceptors(),
	}
}

// Get returns a VaultWithdrawal entity by its id.
func (c *VaultWithdrawalClient) Get(ctx context.Context, id int) (*VaultWithdrawal, error) {
	return c.Query().Where(vaultwithdrawal.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *VaultWithdrawalClient) GetX(ctx context.Context, id int) *VaultWithdrawal {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *VaultWithdrawalClient) Hooks() []Hook {
	return c.hooks.VaultWithdrawal
}

// Interceptors returns the client interceptors.
func (c *VaultWithdrawalClient) Interceptors() []Interceptor {
	return c.inters.VaultWithdrawal
}

func (c *VaultWithdrawalClient) mutate(ctx context.Context, m *VaultWithdrawalMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&VaultWithdrawalCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&VaultWithdrawalUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&VaultWithdrawalUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&VaultWithdrawalDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown VaultWithdrawal mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		Fill, Funding, RewardsClaim, SpotGenesis, VaultDelta, VaultLeaderCommission,
		VaultWithdrawal []ent.Hook
	}
	inters struct {
		Fill, Funding, RewardsClaim, SpotGenesis, VaultDelta, VaultLeaderCommission,
		VaultWithdrawal []ent.Interceptor
	}
)
