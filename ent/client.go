// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"github.com/yoshiso/hypersync/ent/migrate"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"github.com/yoshiso/hypersync/ent/delegate"
	"github.com/yoshiso/hypersync/ent/delegatorreward"
	"github.com/yoshiso/hypersync/ent/fill"
	"github.com/yoshiso/hypersync/ent/funding"
	"github.com/yoshiso/hypersync/ent/hyperunitoperation"
	"github.com/yoshiso/hypersync/ent/internaltransfer"
	"github.com/yoshiso/hypersync/ent/rewardsclaim"
	"github.com/yoshiso/hypersync/ent/spotgenesis"
	"github.com/yoshiso/hypersync/ent/spottransfer"
	"github.com/yoshiso/hypersync/ent/twapslicefill"
	"github.com/yoshiso/hypersync/ent/vaultdelta"
	"github.com/yoshiso/hypersync/ent/vaultleadercommission"
	"github.com/yoshiso/hypersync/ent/vaultwithdrawal"
	"github.com/yoshiso/hypersync/ent/withdraw"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Delegate is the client for interacting with the Delegate builders.
	Delegate *DelegateClient
	// DelegatorReward is the client for interacting with the DelegatorReward builders.
	DelegatorReward *DelegatorRewardClient
	// Fill is the client for interacting with the Fill builders.
	Fill *FillClient
	// Funding is the client for interacting with the Funding builders.
	Funding *FundingClient
	// HyperunitOperation is the client for interacting with the HyperunitOperation builders.
	HyperunitOperation *HyperunitOperationClient
	// InternalTransfer is the client for interacting with the InternalTransfer builders.
	InternalTransfer *InternalTransferClient
	// RewardsClaim is the client for interacting with the RewardsClaim builders.
	RewardsClaim *RewardsClaimClient
	// SpotGenesis is the client for interacting with the SpotGenesis builders.
	SpotGenesis *SpotGenesisClient
	// SpotTransfer is the client for interacting with the SpotTransfer builders.
	SpotTransfer *SpotTransferClient
	// TwapSliceFill is the client for interacting with the TwapSliceFill builders.
	TwapSliceFill *TwapSliceFillClient
	// VaultDelta is the client for interacting with the VaultDelta builders.
	VaultDelta *VaultDeltaClient
	// VaultLeaderCommission is the client for interacting with the VaultLeaderCommission builders.
	VaultLeaderCommission *VaultLeaderCommissionClient
	// VaultWithdrawal is the client for interacting with the VaultWithdrawal builders.
	VaultWithdrawal *VaultWithdrawalClient
	// Withdraw is the client for interacting with the Withdraw builders.
	Withdraw *WithdrawClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Delegate = NewDelegateClient(c.config)
	c.DelegatorReward = NewDelegatorRewardClient(c.config)
	c.Fill = NewFillClient(c.config)
	c.Funding = NewFundingClient(c.config)
	c.HyperunitOperation = NewHyperunitOperationClient(c.config)
	c.InternalTransfer = NewInternalTransferClient(c.config)
	c.RewardsClaim = NewRewardsClaimClient(c.config)
	c.SpotGenesis = NewSpotGenesisClient(c.config)
	c.SpotTransfer = NewSpotTransferClient(c.config)
	c.TwapSliceFill = NewTwapSliceFillClient(c.config)
	c.VaultDelta = NewVaultDeltaClient(c.config)
	c.VaultLeaderCommission = NewVaultLeaderCommissionClient(c.config)
	c.VaultWithdrawal = NewVaultWithdrawalClient(c.config)
	c.Withdraw = NewWithdrawClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                   ctx,
		config:                cfg,
		Delegate:              NewDelegateClient(cfg),
		DelegatorReward:       NewDelegatorRewardClient(cfg),
		Fill:                  NewFillClient(cfg),
		Funding:               NewFundingClient(cfg),
		HyperunitOperation:    NewHyperunitOperationClient(cfg),
		InternalTransfer:      NewInternalTransferClient(cfg),
		RewardsClaim:          NewRewardsClaimClient(cfg),
		SpotGenesis:           NewSpotGenesisClient(cfg),
		SpotTransfer:          NewSpotTransferClient(cfg),
		TwapSliceFill:         NewTwapSliceFillClient(cfg),
		VaultDelta:            NewVaultDeltaClient(cfg),
		VaultLeaderCommission: NewVaultLeaderCommissionClient(cfg),
		VaultWithdrawal:       NewVaultWithdrawalClient(cfg),
		Withdraw:              NewWithdrawClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                   ctx,
		config:                cfg,
		Delegate:              NewDelegateClient(cfg),
		DelegatorReward:       NewDelegatorRewardClient(cfg),
		Fill:                  NewFillClient(cfg),
		Funding:               NewFundingClient(cfg),
		HyperunitOperation:    NewHyperunitOperationClient(cfg),
		InternalTransfer:      NewInternalTransferClient(cfg),
		RewardsClaim:          NewRewardsClaimClient(cfg),
		SpotGenesis:           NewSpotGenesisClient(cfg),
		SpotTransfer:          NewSpotTransferClient(cfg),
		TwapSliceFill:         NewTwapSliceFillClient(cfg),
		VaultDelta:            NewVaultDeltaClient(cfg),
		VaultLeaderCommission: NewVaultLeaderCommissionClient(cfg),
		VaultWithdrawal:       NewVaultWithdrawalClient(cfg),
		Withdraw:              NewWithdrawClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Delegate.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.Delegate, c.DelegatorReward, c.Fill, c.Funding, c.HyperunitOperation,
		c.InternalTransfer, c.RewardsClaim, c.SpotGenesis, c.SpotTransfer,
		c.TwapSliceFill, c.VaultDelta, c.VaultLeaderCommission, c.VaultWithdrawal,
		c.Withdraw,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.Delegate, c.DelegatorReward, c.Fill, c.Funding, c.HyperunitOperation,
		c.InternalTransfer, c.RewardsClaim, c.SpotGenesis, c.SpotTransfer,
		c.TwapSliceFill, c.VaultDelta, c.VaultLeaderCommission, c.VaultWithdrawal,
		c.Withdraw,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *DelegateMutation:
		return c.Delegate.mutate(ctx, m)
	case *DelegatorRewardMutation:
		return c.DelegatorReward.mutate(ctx, m)
	case *FillMutation:
		return c.Fill.mutate(ctx, m)
	case *FundingMutation:
		return c.Funding.mutate(ctx, m)
	case *HyperunitOperationMutation:
		return c.HyperunitOperation.mutate(ctx, m)
	case *InternalTransferMutation:
		return c.InternalTransfer.mutate(ctx, m)
	case *RewardsClaimMutation:
		return c.RewardsClaim.mutate(ctx, m)
	case *SpotGenesisMutation:
		return c.SpotGenesis.mutate(ctx, m)
	case *SpotTransferMutation:
		return c.SpotTransfer.mutate(ctx, m)
	case *TwapSliceFillMutation:
		return c.TwapSliceFill.mutate(ctx, m)
	case *VaultDeltaMutation:
		return c.VaultDelta.mutate(ctx, m)
	case *VaultLeaderCommissionMutation:
		return c.VaultLeaderCommission.mutate(ctx, m)
	case *VaultWithdrawalMutation:
		return c.VaultWithdrawal.mutate(ctx, m)
	case *WithdrawMutation:
		return c.Withdraw.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// DelegateClient is a client for the Delegate schema.
type DelegateClient struct {
	config
}

// NewDelegateClient returns a client for the Delegate from the given config.
func NewDelegateClient(c config) *DelegateClient {
	return &DelegateClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `delegate.Hooks(f(g(h())))`.
func (c *DelegateClient) Use(hooks ...Hook) {
	c.hooks.Delegate = append(c.hooks.Delegate, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `delegate.Intercept(f(g(h())))`.
func (c *DelegateClient) Intercept(interceptors ...Interceptor) {
	c.inters.Delegate = append(c.inters.Delegate, interceptors...)
}

// Create returns a builder for creating a Delegate entity.
func (c *DelegateClient) Create() *DelegateCreate {
	mutation := newDelegateMutation(c.config, OpCreate)
	return &DelegateCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Delegate entities.
func (c *DelegateClient) CreateBulk(builders ...*DelegateCreate) *DelegateCreateBulk {
	return &DelegateCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DelegateClient) MapCreateBulk(slice any, setFunc func(*DelegateCreate, int)) *DelegateCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DelegateCreateBulk{err: fmt.Errorf("calling to DelegateClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DelegateCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DelegateCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Delegate.
func (c *DelegateClient) Update() *DelegateUpdate {
	mutation := newDelegateMutation(c.config, OpUpdate)
	return &DelegateUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DelegateClient) UpdateOne(d *Delegate) *DelegateUpdateOne {
	mutation := newDelegateMutation(c.config, OpUpdateOne, withDelegate(d))
	return &DelegateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DelegateClient) UpdateOneID(id int) *DelegateUpdateOne {
	mutation := newDelegateMutation(c.config, OpUpdateOne, withDelegateID(id))
	return &DelegateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Delegate.
func (c *DelegateClient) Delete() *DelegateDelete {
	mutation := newDelegateMutation(c.config, OpDelete)
	return &DelegateDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DelegateClient) DeleteOne(d *Delegate) *DelegateDeleteOne {
	return c.DeleteOneID(d.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DelegateClient) DeleteOneID(id int) *DelegateDeleteOne {
	builder := c.Delete().Where(delegate.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DelegateDeleteOne{builder}
}

// Query returns a query builder for Delegate.
func (c *DelegateClient) Query() *DelegateQuery {
	return &DelegateQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDelegate},
		inters: c.Interceptors(),
	}
}

// Get returns a Delegate entity by its id.
func (c *DelegateClient) Get(ctx context.Context, id int) (*Delegate, error) {
	return c.Query().Where(delegate.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DelegateClient) GetX(ctx context.Context, id int) *Delegate {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *DelegateClient) Hooks() []Hook {
	return c.hooks.Delegate
}

// Interceptors returns the client interceptors.
func (c *DelegateClient) Interceptors() []Interceptor {
	return c.inters.Delegate
}

func (c *DelegateClient) mutate(ctx context.Context, m *DelegateMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DelegateCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DelegateUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DelegateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DelegateDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Delegate mutation op: %q", m.Op())
	}
}

// DelegatorRewardClient is a client for the DelegatorReward schema.
type DelegatorRewardClient struct {
	config
}

// NewDelegatorRewardClient returns a client for the DelegatorReward from the given config.
func NewDelegatorRewardClient(c config) *DelegatorRewardClient {
	return &DelegatorRewardClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `delegatorreward.Hooks(f(g(h())))`.
func (c *DelegatorRewardClient) Use(hooks ...Hook) {
	c.hooks.DelegatorReward = append(c.hooks.DelegatorReward, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `delegatorreward.Intercept(f(g(h())))`.
func (c *DelegatorRewardClient) Intercept(interceptors ...Interceptor) {
	c.inters.DelegatorReward = append(c.inters.DelegatorReward, interceptors...)
}

// Create returns a builder for creating a DelegatorReward entity.
func (c *DelegatorRewardClient) Create() *DelegatorRewardCreate {
	mutation := newDelegatorRewardMutation(c.config, OpCreate)
	return &DelegatorRewardCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of DelegatorReward entities.
func (c *DelegatorRewardClient) CreateBulk(builders ...*DelegatorRewardCreate) *DelegatorRewardCreateBulk {
	return &DelegatorRewardCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DelegatorRewardClient) MapCreateBulk(slice any, setFunc func(*DelegatorRewardCreate, int)) *DelegatorRewardCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DelegatorRewardCreateBulk{err: fmt.Errorf("calling to DelegatorRewardClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DelegatorRewardCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DelegatorRewardCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for DelegatorReward.
func (c *DelegatorRewardClient) Update() *DelegatorRewardUpdate {
	mutation := newDelegatorRewardMutation(c.config, OpUpdate)
	return &DelegatorRewardUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DelegatorRewardClient) UpdateOne(dr *DelegatorReward) *DelegatorRewardUpdateOne {
	mutation := newDelegatorRewardMutation(c.config, OpUpdateOne, withDelegatorReward(dr))
	return &DelegatorRewardUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DelegatorRewardClient) UpdateOneID(id int) *DelegatorRewardUpdateOne {
	mutation := newDelegatorRewardMutation(c.config, OpUpdateOne, withDelegatorRewardID(id))
	return &DelegatorRewardUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for DelegatorReward.
func (c *DelegatorRewardClient) Delete() *DelegatorRewardDelete {
	mutation := newDelegatorRewardMutation(c.config, OpDelete)
	return &DelegatorRewardDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DelegatorRewardClient) DeleteOne(dr *DelegatorReward) *DelegatorRewardDeleteOne {
	return c.DeleteOneID(dr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DelegatorRewardClient) DeleteOneID(id int) *DelegatorRewardDeleteOne {
	builder := c.Delete().Where(delegatorreward.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DelegatorRewardDeleteOne{builder}
}

// Query returns a query builder for DelegatorReward.
func (c *DelegatorRewardClient) Query() *DelegatorRewardQuery {
	return &DelegatorRewardQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDelegatorReward},
		inters: c.Interceptors(),
	}
}

// Get returns a DelegatorReward entity by its id.
func (c *DelegatorRewardClient) Get(ctx context.Context, id int) (*DelegatorReward, error) {
	return c.Query().Where(delegatorreward.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DelegatorRewardClient) GetX(ctx context.Context, id int) *DelegatorReward {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *DelegatorRewardClient) Hooks() []Hook {
	return c.hooks.DelegatorReward
}

// Interceptors returns the client interceptors.
func (c *DelegatorRewardClient) Interceptors() []Interceptor {
	return c.inters.DelegatorReward
}

func (c *DelegatorRewardClient) mutate(ctx context.Context, m *DelegatorRewardMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DelegatorRewardCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DelegatorRewardUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DelegatorRewardUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DelegatorRewardDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown DelegatorReward mutation op: %q", m.Op())
	}
}

// FillClient is a client for the Fill schema.
type FillClient struct {
	config
}

// NewFillClient returns a client for the Fill from the given config.
func NewFillClient(c config) *FillClient {
	return &FillClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `fill.Hooks(f(g(h())))`.
func (c *FillClient) Use(hooks ...Hook) {
	c.hooks.Fill = append(c.hooks.Fill, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `fill.Intercept(f(g(h())))`.
func (c *FillClient) Intercept(interceptors ...Interceptor) {
	c.inters.Fill = append(c.inters.Fill, interceptors...)
}

// Create returns a builder for creating a Fill entity.
func (c *FillClient) Create() *FillCreate {
	mutation := newFillMutation(c.config, OpCreate)
	return &FillCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Fill entities.
func (c *FillClient) CreateBulk(builders ...*FillCreate) *FillCreateBulk {
	return &FillCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FillClient) MapCreateBulk(slice any, setFunc func(*FillCreate, int)) *FillCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FillCreateBulk{err: fmt.Errorf("calling to FillClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FillCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FillCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Fill.
func (c *FillClient) Update() *FillUpdate {
	mutation := newFillMutation(c.config, OpUpdate)
	return &FillUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FillClient) UpdateOne(f *Fill) *FillUpdateOne {
	mutation := newFillMutation(c.config, OpUpdateOne, withFill(f))
	return &FillUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FillClient) UpdateOneID(id int) *FillUpdateOne {
	mutation := newFillMutation(c.config, OpUpdateOne, withFillID(id))
	return &FillUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Fill.
func (c *FillClient) Delete() *FillDelete {
	mutation := newFillMutation(c.config, OpDelete)
	return &FillDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FillClient) DeleteOne(f *Fill) *FillDeleteOne {
	return c.DeleteOneID(f.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FillClient) DeleteOneID(id int) *FillDeleteOne {
	builder := c.Delete().Where(fill.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FillDeleteOne{builder}
}

// Query returns a query builder for Fill.
func (c *FillClient) Query() *FillQuery {
	return &FillQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFill},
		inters: c.Interceptors(),
	}
}

// Get returns a Fill entity by its id.
func (c *FillClient) Get(ctx context.Context, id int) (*Fill, error) {
	return c.Query().Where(fill.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FillClient) GetX(ctx context.Context, id int) *Fill {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *FillClient) Hooks() []Hook {
	return c.hooks.Fill
}

// Interceptors returns the client interceptors.
func (c *FillClient) Interceptors() []Interceptor {
	return c.inters.Fill
}

func (c *FillClient) mutate(ctx context.Context, m *FillMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FillCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FillUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FillUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FillDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Fill mutation op: %q", m.Op())
	}
}

// FundingClient is a client for the Funding schema.
type FundingClient struct {
	config
}

// NewFundingClient returns a client for the Funding from the given config.
func NewFundingClient(c config) *FundingClient {
	return &FundingClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `funding.Hooks(f(g(h())))`.
func (c *FundingClient) Use(hooks ...Hook) {
	c.hooks.Funding = append(c.hooks.Funding, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `funding.Intercept(f(g(h())))`.
func (c *FundingClient) Intercept(interceptors ...Interceptor) {
	c.inters.Funding = append(c.inters.Funding, interceptors...)
}

// Create returns a builder for creating a Funding entity.
func (c *FundingClient) Create() *FundingCreate {
	mutation := newFundingMutation(c.config, OpCreate)
	return &FundingCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Funding entities.
func (c *FundingClient) CreateBulk(builders ...*FundingCreate) *FundingCreateBulk {
	return &FundingCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FundingClient) MapCreateBulk(slice any, setFunc func(*FundingCreate, int)) *FundingCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FundingCreateBulk{err: fmt.Errorf("calling to FundingClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FundingCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FundingCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Funding.
func (c *FundingClient) Update() *FundingUpdate {
	mutation := newFundingMutation(c.config, OpUpdate)
	return &FundingUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FundingClient) UpdateOne(f *Funding) *FundingUpdateOne {
	mutation := newFundingMutation(c.config, OpUpdateOne, withFunding(f))
	return &FundingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FundingClient) UpdateOneID(id int) *FundingUpdateOne {
	mutation := newFundingMutation(c.config, OpUpdateOne, withFundingID(id))
	return &FundingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Funding.
func (c *FundingClient) Delete() *FundingDelete {
	mutation := newFundingMutation(c.config, OpDelete)
	return &FundingDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FundingClient) DeleteOne(f *Funding) *FundingDeleteOne {
	return c.DeleteOneID(f.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FundingClient) DeleteOneID(id int) *FundingDeleteOne {
	builder := c.Delete().Where(funding.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FundingDeleteOne{builder}
}

// Query returns a query builder for Funding.
func (c *FundingClient) Query() *FundingQuery {
	return &FundingQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFunding},
		inters: c.Interceptors(),
	}
}

// Get returns a Funding entity by its id.
func (c *FundingClient) Get(ctx context.Context, id int) (*Funding, error) {
	return c.Query().Where(funding.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FundingClient) GetX(ctx context.Context, id int) *Funding {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *FundingClient) Hooks() []Hook {
	return c.hooks.Funding
}

// Interceptors returns the client interceptors.
func (c *FundingClient) Interceptors() []Interceptor {
	return c.inters.Funding
}

func (c *FundingClient) mutate(ctx context.Context, m *FundingMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FundingCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FundingUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FundingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FundingDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Funding mutation op: %q", m.Op())
	}
}

// HyperunitOperationClient is a client for the HyperunitOperation schema.
type HyperunitOperationClient struct {
	config
}

// NewHyperunitOperationClient returns a client for the HyperunitOperation from the given config.
func NewHyperunitOperationClient(c config) *HyperunitOperationClient {
	return &HyperunitOperationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `hyperunitoperation.Hooks(f(g(h())))`.
func (c *HyperunitOperationClient) Use(hooks ...Hook) {
	c.hooks.HyperunitOperation = append(c.hooks.HyperunitOperation, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `hyperunitoperation.Intercept(f(g(h())))`.
func (c *HyperunitOperationClient) Intercept(interceptors ...Interceptor) {
	c.inters.HyperunitOperation = append(c.inters.HyperunitOperation, interceptors...)
}

// Create returns a builder for creating a HyperunitOperation entity.
func (c *HyperunitOperationClient) Create() *HyperunitOperationCreate {
	mutation := newHyperunitOperationMutation(c.config, OpCreate)
	return &HyperunitOperationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of HyperunitOperation entities.
func (c *HyperunitOperationClient) CreateBulk(builders ...*HyperunitOperationCreate) *HyperunitOperationCreateBulk {
	return &HyperunitOperationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *HyperunitOperationClient) MapCreateBulk(slice any, setFunc func(*HyperunitOperationCreate, int)) *HyperunitOperationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &HyperunitOperationCreateBulk{err: fmt.Errorf("calling to HyperunitOperationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*HyperunitOperationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &HyperunitOperationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for HyperunitOperation.
func (c *HyperunitOperationClient) Update() *HyperunitOperationUpdate {
	mutation := newHyperunitOperationMutation(c.config, OpUpdate)
	return &HyperunitOperationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *HyperunitOperationClient) UpdateOne(ho *HyperunitOperation) *HyperunitOperationUpdateOne {
	mutation := newHyperunitOperationMutation(c.config, OpUpdateOne, withHyperunitOperation(ho))
	return &HyperunitOperationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *HyperunitOperationClient) UpdateOneID(id int) *HyperunitOperationUpdateOne {
	mutation := newHyperunitOperationMutation(c.config, OpUpdateOne, withHyperunitOperationID(id))
	return &HyperunitOperationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for HyperunitOperation.
func (c *HyperunitOperationClient) Delete() *HyperunitOperationDelete {
	mutation := newHyperunitOperationMutation(c.config, OpDelete)
	return &HyperunitOperationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *HyperunitOperationClient) DeleteOne(ho *HyperunitOperation) *HyperunitOperationDeleteOne {
	return c.DeleteOneID(ho.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *HyperunitOperationClient) DeleteOneID(id int) *HyperunitOperationDeleteOne {
	builder := c.Delete().Where(hyperunitoperation.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &HyperunitOperationDeleteOne{builder}
}

// Query returns a query builder for HyperunitOperation.
func (c *HyperunitOperationClient) Query() *HyperunitOperationQuery {
	return &HyperunitOperationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeHyperunitOperation},
		inters: c.Interceptors(),
	}
}

// Get returns a HyperunitOperation entity by its id.
func (c *HyperunitOperationClient) Get(ctx context.Context, id int) (*HyperunitOperation, error) {
	return c.Query().Where(hyperunitoperation.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *HyperunitOperationClient) GetX(ctx context.Context, id int) *HyperunitOperation {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *HyperunitOperationClient) Hooks() []Hook {
	return c.hooks.HyperunitOperation
}

// Interceptors returns the client interceptors.
func (c *HyperunitOperationClient) Interceptors() []Interceptor {
	return c.inters.HyperunitOperation
}

func (c *HyperunitOperationClient) mutate(ctx context.Context, m *HyperunitOperationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&HyperunitOperationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&HyperunitOperationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&HyperunitOperationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&HyperunitOperationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown HyperunitOperation mutation op: %q", m.Op())
	}
}

// InternalTransferClient is a client for the InternalTransfer schema.
type InternalTransferClient struct {
	config
}

// NewInternalTransferClient returns a client for the InternalTransfer from the given config.
func NewInternalTransferClient(c config) *InternalTransferClient {
	return &InternalTransferClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `internaltransfer.Hooks(f(g(h())))`.
func (c *InternalTransferClient) Use(hooks ...Hook) {
	c.hooks.InternalTransfer = append(c.hooks.InternalTransfer, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `internaltransfer.Intercept(f(g(h())))`.
func (c *InternalTransferClient) Intercept(interceptors ...Interceptor) {
	c.inters.InternalTransfer = append(c.inters.InternalTransfer, interceptors...)
}

// Create returns a builder for creating a InternalTransfer entity.
func (c *InternalTransferClient) Create() *InternalTransferCreate {
	mutation := newInternalTransferMutation(c.config, OpCreate)
	return &InternalTransferCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of InternalTransfer entities.
func (c *InternalTransferClient) CreateBulk(builders ...*InternalTransferCreate) *InternalTransferCreateBulk {
	return &InternalTransferCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *InternalTransferClient) MapCreateBulk(slice any, setFunc func(*InternalTransferCreate, int)) *InternalTransferCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &InternalTransferCreateBulk{err: fmt.Errorf("calling to InternalTransferClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*InternalTransferCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &InternalTransferCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for InternalTransfer.
func (c *InternalTransferClient) Update() *InternalTransferUpdate {
	mutation := newInternalTransferMutation(c.config, OpUpdate)
	return &InternalTransferUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *InternalTransferClient) UpdateOne(it *InternalTransfer) *InternalTransferUpdateOne {
	mutation := newInternalTransferMutation(c.config, OpUpdateOne, withInternalTransfer(it))
	return &InternalTransferUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *InternalTransferClient) UpdateOneID(id int) *InternalTransferUpdateOne {
	mutation := newInternalTransferMutation(c.config, OpUpdateOne, withInternalTransferID(id))
	return &InternalTransferUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for InternalTransfer.
func (c *InternalTransferClient) Delete() *InternalTransferDelete {
	mutation := newInternalTransferMutation(c.config, OpDelete)
	return &InternalTransferDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *InternalTransferClient) DeleteOne(it *InternalTransfer) *InternalTransferDeleteOne {
	return c.DeleteOneID(it.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *InternalTransferClient) DeleteOneID(id int) *InternalTransferDeleteOne {
	builder := c.Delete().Where(internaltransfer.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &InternalTransferDeleteOne{builder}
}

// Query returns a query builder for InternalTransfer.
func (c *InternalTransferClient) Query() *InternalTransferQuery {
	return &InternalTransferQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeInternalTransfer},
		inters: c.Interceptors(),
	}
}

// Get returns a InternalTransfer entity by its id.
func (c *InternalTransferClient) Get(ctx context.Context, id int) (*InternalTransfer, error) {
	return c.Query().Where(internaltransfer.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *InternalTransferClient) GetX(ctx context.Context, id int) *InternalTransfer {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *InternalTransferClient) Hooks() []Hook {
	return c.hooks.InternalTransfer
}

// Interceptors returns the client interceptors.
func (c *InternalTransferClient) Interceptors() []Interceptor {
	return c.inters.InternalTransfer
}

func (c *InternalTransferClient) mutate(ctx context.Context, m *InternalTransferMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&InternalTransferCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&InternalTransferUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&InternalTransferUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&InternalTransferDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown InternalTransfer mutation op: %q", m.Op())
	}
}

// RewardsClaimClient is a client for the RewardsClaim schema.
type RewardsClaimClient struct {
	config
}

// NewRewardsClaimClient returns a client for the RewardsClaim from the given config.
func NewRewardsClaimClient(c config) *RewardsClaimClient {
	return &RewardsClaimClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `rewardsclaim.Hooks(f(g(h())))`.
func (c *RewardsClaimClient) Use(hooks ...Hook) {
	c.hooks.RewardsClaim = append(c.hooks.RewardsClaim, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `rewardsclaim.Intercept(f(g(h())))`.
func (c *RewardsClaimClient) Intercept(interceptors ...Interceptor) {
	c.inters.RewardsClaim = append(c.inters.RewardsClaim, interceptors...)
}

// Create returns a builder for creating a RewardsClaim entity.
func (c *RewardsClaimClient) Create() *RewardsClaimCreate {
	mutation := newRewardsClaimMutation(c.config, OpCreate)
	return &RewardsClaimCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of RewardsClaim entities.
func (c *RewardsClaimClient) CreateBulk(builders ...*RewardsClaimCreate) *RewardsClaimCreateBulk {
	return &RewardsClaimCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RewardsClaimClient) MapCreateBulk(slice any, setFunc func(*RewardsClaimCreate, int)) *RewardsClaimCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RewardsClaimCreateBulk{err: fmt.Errorf("calling to RewardsClaimClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RewardsClaimCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RewardsClaimCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for RewardsClaim.
func (c *RewardsClaimClient) Update() *RewardsClaimUpdate {
	mutation := newRewardsClaimMutation(c.config, OpUpdate)
	return &RewardsClaimUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RewardsClaimClient) UpdateOne(rc *RewardsClaim) *RewardsClaimUpdateOne {
	mutation := newRewardsClaimMutation(c.config, OpUpdateOne, withRewardsClaim(rc))
	return &RewardsClaimUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RewardsClaimClient) UpdateOneID(id int) *RewardsClaimUpdateOne {
	mutation := newRewardsClaimMutation(c.config, OpUpdateOne, withRewardsClaimID(id))
	return &RewardsClaimUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for RewardsClaim.
func (c *RewardsClaimClient) Delete() *RewardsClaimDelete {
	mutation := newRewardsClaimMutation(c.config, OpDelete)
	return &RewardsClaimDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RewardsClaimClient) DeleteOne(rc *RewardsClaim) *RewardsClaimDeleteOne {
	return c.DeleteOneID(rc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RewardsClaimClient) DeleteOneID(id int) *RewardsClaimDeleteOne {
	builder := c.Delete().Where(rewardsclaim.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RewardsClaimDeleteOne{builder}
}

// Query returns a query builder for RewardsClaim.
func (c *RewardsClaimClient) Query() *RewardsClaimQuery {
	return &RewardsClaimQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRewardsClaim},
		inters: c.Interceptors(),
	}
}

// Get returns a RewardsClaim entity by its id.
func (c *RewardsClaimClient) Get(ctx context.Context, id int) (*RewardsClaim, error) {
	return c.Query().Where(rewardsclaim.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RewardsClaimClient) GetX(ctx context.Context, id int) *RewardsClaim {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *RewardsClaimClient) Hooks() []Hook {
	return c.hooks.RewardsClaim
}

// Interceptors returns the client interceptors.
func (c *RewardsClaimClient) Interceptors() []Interceptor {
	return c.inters.RewardsClaim
}

func (c *RewardsClaimClient) mutate(ctx context.Context, m *RewardsClaimMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RewardsClaimCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RewardsClaimUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RewardsClaimUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RewardsClaimDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown RewardsClaim mutation op: %q", m.Op())
	}
}

// SpotGenesisClient is a client for the SpotGenesis schema.
type SpotGenesisClient struct {
	config
}

// NewSpotGenesisClient returns a client for the SpotGenesis from the given config.
func NewSpotGenesisClient(c config) *SpotGenesisClient {
	return &SpotGenesisClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `spotgenesis.Hooks(f(g(h())))`.
func (c *SpotGenesisClient) Use(hooks ...Hook) {
	c.hooks.SpotGenesis = append(c.hooks.SpotGenesis, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `spotgenesis.Intercept(f(g(h())))`.
func (c *SpotGenesisClient) Intercept(interceptors ...Interceptor) {
	c.inters.SpotGenesis = append(c.inters.SpotGenesis, interceptors...)
}

// Create returns a builder for creating a SpotGenesis entity.
func (c *SpotGenesisClient) Create() *SpotGenesisCreate {
	mutation := newSpotGenesisMutation(c.config, OpCreate)
	return &SpotGenesisCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SpotGenesis entities.
func (c *SpotGenesisClient) CreateBulk(builders ...*SpotGenesisCreate) *SpotGenesisCreateBulk {
	return &SpotGenesisCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SpotGenesisClient) MapCreateBulk(slice any, setFunc func(*SpotGenesisCreate, int)) *SpotGenesisCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SpotGenesisCreateBulk{err: fmt.Errorf("calling to SpotGenesisClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SpotGenesisCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SpotGenesisCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SpotGenesis.
func (c *SpotGenesisClient) Update() *SpotGenesisUpdate {
	mutation := newSpotGenesisMutation(c.config, OpUpdate)
	return &SpotGenesisUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SpotGenesisClient) UpdateOne(sg *SpotGenesis) *SpotGenesisUpdateOne {
	mutation := newSpotGenesisMutation(c.config, OpUpdateOne, withSpotGenesis(sg))
	return &SpotGenesisUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SpotGenesisClient) UpdateOneID(id int) *SpotGenesisUpdateOne {
	mutation := newSpotGenesisMutation(c.config, OpUpdateOne, withSpotGenesisID(id))
	return &SpotGenesisUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SpotGenesis.
func (c *SpotGenesisClient) Delete() *SpotGenesisDelete {
	mutation := newSpotGenesisMutation(c.config, OpDelete)
	return &SpotGenesisDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SpotGenesisClient) DeleteOne(sg *SpotGenesis) *SpotGenesisDeleteOne {
	return c.DeleteOneID(sg.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SpotGenesisClient) DeleteOneID(id int) *SpotGenesisDeleteOne {
	builder := c.Delete().Where(spotgenesis.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SpotGenesisDeleteOne{builder}
}

// Query returns a query builder for SpotGenesis.
func (c *SpotGenesisClient) Query() *SpotGenesisQuery {
	return &SpotGenesisQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSpotGenesis},
		inters: c.Interceptors(),
	}
}

// Get returns a SpotGenesis entity by its id.
func (c *SpotGenesisClient) Get(ctx context.Context, id int) (*SpotGenesis, error) {
	return c.Query().Where(spotgenesis.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SpotGenesisClient) GetX(ctx context.Context, id int) *SpotGenesis {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *SpotGenesisClient) Hooks() []Hook {
	return c.hooks.SpotGenesis
}

// Interceptors returns the client interceptors.
func (c *SpotGenesisClient) Interceptors() []Interceptor {
	return c.inters.SpotGenesis
}

func (c *SpotGenesisClient) mutate(ctx context.Context, m *SpotGenesisMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SpotGenesisCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SpotGenesisUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SpotGenesisUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SpotGenesisDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SpotGenesis mutation op: %q", m.Op())
	}
}

// SpotTransferClient is a client for the SpotTransfer schema.
type SpotTransferClient struct {
	config
}

// NewSpotTransferClient returns a client for the SpotTransfer from the given config.
func NewSpotTransferClient(c config) *SpotTransferClient {
	return &SpotTransferClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `spottransfer.Hooks(f(g(h())))`.
func (c *SpotTransferClient) Use(hooks ...Hook) {
	c.hooks.SpotTransfer = append(c.hooks.SpotTransfer, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `spottransfer.Intercept(f(g(h())))`.
func (c *SpotTransferClient) Intercept(interceptors ...Interceptor) {
	c.inters.SpotTransfer = append(c.inters.SpotTransfer, interceptors...)
}

// Create returns a builder for creating a SpotTransfer entity.
func (c *SpotTransferClient) Create() *SpotTransferCreate {
	mutation := newSpotTransferMutation(c.config, OpCreate)
	return &SpotTransferCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SpotTransfer entities.
func (c *SpotTransferClient) CreateBulk(builders ...*SpotTransferCreate) *SpotTransferCreateBulk {
	return &SpotTransferCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SpotTransferClient) MapCreateBulk(slice any, setFunc func(*SpotTransferCreate, int)) *SpotTransferCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SpotTransferCreateBulk{err: fmt.Errorf("calling to SpotTransferClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SpotTransferCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SpotTransferCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SpotTransfer.
func (c *SpotTransferClient) Update() *SpotTransferUpdate {
	mutation := newSpotTransferMutation(c.config, OpUpdate)
	return &SpotTransferUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SpotTransferClient) UpdateOne(st *SpotTransfer) *SpotTransferUpdateOne {
	mutation := newSpotTransferMutation(c.config, OpUpdateOne, withSpotTransfer(st))
	return &SpotTransferUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SpotTransferClient) UpdateOneID(id int) *SpotTransferUpdateOne {
	mutation := newSpotTransferMutation(c.config, OpUpdateOne, withSpotTransferID(id))
	return &SpotTransferUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SpotTransfer.
func (c *SpotTransferClient) Delete() *SpotTransferDelete {
	mutation := newSpotTransferMutation(c.config, OpDelete)
	return &SpotTransferDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SpotTransferClient) DeleteOne(st *SpotTransfer) *SpotTransferDeleteOne {
	return c.DeleteOneID(st.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SpotTransferClient) DeleteOneID(id int) *SpotTransferDeleteOne {
	builder := c.Delete().Where(spottransfer.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SpotTransferDeleteOne{builder}
}

// Query returns a query builder for SpotTransfer.
func (c *SpotTransferClient) Query() *SpotTransferQuery {
	return &SpotTransferQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSpotTransfer},
		inters: c.Interceptors(),
	}
}

// Get returns a SpotTransfer entity by its id.
func (c *SpotTransferClient) Get(ctx context.Context, id int) (*SpotTransfer, error) {
	return c.Query().Where(spottransfer.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SpotTransferClient) GetX(ctx context.Context, id int) *SpotTransfer {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *SpotTransferClient) Hooks() []Hook {
	return c.hooks.SpotTransfer
}

// Interceptors returns the client interceptors.
func (c *SpotTransferClient) Interceptors() []Interceptor {
	return c.inters.SpotTransfer
}

func (c *SpotTransferClient) mutate(ctx context.Context, m *SpotTransferMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SpotTransferCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SpotTransferUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SpotTransferUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SpotTransferDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SpotTransfer mutation op: %q", m.Op())
	}
}

// TwapSliceFillClient is a client for the TwapSliceFill schema.
type TwapSliceFillClient struct {
	config
}

// NewTwapSliceFillClient returns a client for the TwapSliceFill from the given config.
func NewTwapSliceFillClient(c config) *TwapSliceFillClient {
	return &TwapSliceFillClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `twapslicefill.Hooks(f(g(h())))`.
func (c *TwapSliceFillClient) Use(hooks ...Hook) {
	c.hooks.TwapSliceFill = append(c.hooks.TwapSliceFill, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `twapslicefill.Intercept(f(g(h())))`.
func (c *TwapSliceFillClient) Intercept(interceptors ...Interceptor) {
	c.inters.TwapSliceFill = append(c.inters.TwapSliceFill, interceptors...)
}

// Create returns a builder for creating a TwapSliceFill entity.
func (c *TwapSliceFillClient) Create() *TwapSliceFillCreate {
	mutation := newTwapSliceFillMutation(c.config, OpCreate)
	return &TwapSliceFillCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TwapSliceFill entities.
func (c *TwapSliceFillClient) CreateBulk(builders ...*TwapSliceFillCreate) *TwapSliceFillCreateBulk {
	return &TwapSliceFillCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TwapSliceFillClient) MapCreateBulk(slice any, setFunc func(*TwapSliceFillCreate, int)) *TwapSliceFillCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TwapSliceFillCreateBulk{err: fmt.Errorf("calling to TwapSliceFillClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TwapSliceFillCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TwapSliceFillCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TwapSliceFill.
func (c *TwapSliceFillClient) Update() *TwapSliceFillUpdate {
	mutation := newTwapSliceFillMutation(c.config, OpUpdate)
	return &TwapSliceFillUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TwapSliceFillClient) UpdateOne(tsf *TwapSliceFill) *TwapSliceFillUpdateOne {
	mutation := newTwapSliceFillMutation(c.config, OpUpdateOne, withTwapSliceFill(tsf))
	return &TwapSliceFillUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TwapSliceFillClient) UpdateOneID(id int) *TwapSliceFillUpdateOne {
	mutation := newTwapSliceFillMutation(c.config, OpUpdateOne, withTwapSliceFillID(id))
	return &TwapSliceFillUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TwapSliceFill.
func (c *TwapSliceFillClient) Delete() *TwapSliceFillDelete {
	mutation := newTwapSliceFillMutation(c.config, OpDelete)
	return &TwapSliceFillDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TwapSliceFillClient) DeleteOne(tsf *TwapSliceFill) *TwapSliceFillDeleteOne {
	return c.DeleteOneID(tsf.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TwapSliceFillClient) DeleteOneID(id int) *TwapSliceFillDeleteOne {
	builder := c.Delete().Where(twapslicefill.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TwapSliceFillDeleteOne{builder}
}

// Query returns a query builder for TwapSliceFill.
func (c *TwapSliceFillClient) Query() *TwapSliceFillQuery {
	return &TwapSliceFillQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTwapSliceFill},
		inters: c.Interceptors(),
	}
}

// Get returns a TwapSliceFill entity by its id.
func (c *TwapSliceFillClient) Get(ctx context.Context, id int) (*TwapSliceFill, error) {
	return c.Query().Where(twapslicefill.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TwapSliceFillClient) GetX(ctx context.Context, id int) *TwapSliceFill {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *TwapSliceFillClient) Hooks() []Hook {
	return c.hooks.TwapSliceFill
}

// Interceptors returns the client interceptors.
func (c *TwapSliceFillClient) Interceptors() []Interceptor {
	return c.inters.TwapSliceFill
}

func (c *TwapSliceFillClient) mutate(ctx context.Context, m *TwapSliceFillMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TwapSliceFillCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TwapSliceFillUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TwapSliceFillUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TwapSliceFillDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown TwapSliceFill mutation op: %q", m.Op())
	}
}

// VaultDeltaClient is a client for the VaultDelta schema.
type VaultDeltaClient struct {
	config
}

// NewVaultDeltaClient returns a client for the VaultDelta from the given config.
func NewVaultDeltaClient(c config) *VaultDeltaClient {
	return &VaultDeltaClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `vaultdelta.Hooks(f(g(h())))`.
func (c *VaultDeltaClient) Use(hooks ...Hook) {
	c.hooks.VaultDelta = append(c.hooks.VaultDelta, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `vaultdelta.Intercept(f(g(h())))`.
func (c *VaultDeltaClient) Intercept(interceptors ...Interceptor) {
	c.inters.VaultDelta = append(c.inters.VaultDelta, interceptors...)
}

// Create returns a builder for creating a VaultDelta entity.
func (c *VaultDeltaClient) Create() *VaultDeltaCreate {
	mutation := newVaultDeltaMutation(c.config, OpCreate)
	return &VaultDeltaCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of VaultDelta entities.
func (c *VaultDeltaClient) CreateBulk(builders ...*VaultDeltaCreate) *VaultDeltaCreateBulk {
	return &VaultDeltaCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *VaultDeltaClient) MapCreateBulk(slice any, setFunc func(*VaultDeltaCreate, int)) *VaultDeltaCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &VaultDeltaCreateBulk{err: fmt.Errorf("calling to VaultDeltaClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*VaultDeltaCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &VaultDeltaCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for VaultDelta.
func (c *VaultDeltaClient) Update() *VaultDeltaUpdate {
	mutation := newVaultDeltaMutation(c.config, OpUpdate)
	return &VaultDeltaUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VaultDeltaClient) UpdateOne(vd *VaultDelta) *VaultDeltaUpdateOne {
	mutation := newVaultDeltaMutation(c.config, OpUpdateOne, withVaultDelta(vd))
	return &VaultDeltaUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *VaultDeltaClient) UpdateOneID(id int) *VaultDeltaUpdateOne {
	mutation := newVaultDeltaMutation(c.config, OpUpdateOne, withVaultDeltaID(id))
	return &VaultDeltaUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for VaultDelta.
func (c *VaultDeltaClient) Delete() *VaultDeltaDelete {
	mutation := newVaultDeltaMutation(c.config, OpDelete)
	return &VaultDeltaDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *VaultDeltaClient) DeleteOne(vd *VaultDelta) *VaultDeltaDeleteOne {
	return c.DeleteOneID(vd.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *VaultDeltaClient) DeleteOneID(id int) *VaultDeltaDeleteOne {
	builder := c.Delete().Where(vaultdelta.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &VaultDeltaDeleteOne{builder}
}

// Query returns a query builder for VaultDelta.
func (c *VaultDeltaClient) Query() *VaultDeltaQuery {
	return &VaultDeltaQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeVaultDelta},
		inters: c.Interceptors(),
	}
}

// Get returns a VaultDelta entity by its id.
func (c *VaultDeltaClient) Get(ctx context.Context, id int) (*VaultDelta, error) {
	return c.Query().Where(vaultdelta.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *VaultDeltaClient) GetX(ctx context.Context, id int) *VaultDelta {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *VaultDeltaClient) Hooks() []Hook {
	return c.hooks.VaultDelta
}

// Interceptors returns the client interceptors.
func (c *VaultDeltaClient) Interceptors() []Interceptor {
	return c.inters.VaultDelta
}

func (c *VaultDeltaClient) mutate(ctx context.Context, m *VaultDeltaMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&VaultDeltaCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&VaultDeltaUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&VaultDeltaUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&VaultDeltaDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown VaultDelta mutation op: %q", m.Op())
	}
}

// VaultLeaderCommissionClient is a client for the VaultLeaderCommission schema.
type VaultLeaderCommissionClient struct {
	config
}

// NewVaultLeaderCommissionClient returns a client for the VaultLeaderCommission from the given config.
func NewVaultLeaderCommissionClient(c config) *VaultLeaderCommissionClient {
	return &VaultLeaderCommissionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `vaultleadercommission.Hooks(f(g(h())))`.
func (c *VaultLeaderCommissionClient) Use(hooks ...Hook) {
	c.hooks.VaultLeaderCommission = append(c.hooks.VaultLeaderCommission, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `vaultleadercommission.Intercept(f(g(h())))`.
func (c *VaultLeaderCommissionClient) Intercept(interceptors ...Interceptor) {
	c.inters.VaultLeaderCommission = append(c.inters.VaultLeaderCommission, interceptors...)
}

// Create returns a builder for creating a VaultLeaderCommission entity.
func (c *VaultLeaderCommissionClient) Create() *VaultLeaderCommissionCreate {
	mutation := newVaultLeaderCommissionMutation(c.config, OpCreate)
	return &VaultLeaderCommissionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of VaultLeaderCommission entities.
func (c *VaultLeaderCommissionClient) CreateBulk(builders ...*VaultLeaderCommissionCreate) *VaultLeaderCommissionCreateBulk {
	return &VaultLeaderCommissionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *VaultLeaderCommissionClient) MapCreateBulk(slice any, setFunc func(*VaultLeaderCommissionCreate, int)) *VaultLeaderCommissionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &VaultLeaderCommissionCreateBulk{err: fmt.Errorf("calling to VaultLeaderCommissionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*VaultLeaderCommissionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &VaultLeaderCommissionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for VaultLeaderCommission.
func (c *VaultLeaderCommissionClient) Update() *VaultLeaderCommissionUpdate {
	mutation := newVaultLeaderCommissionMutation(c.config, OpUpdate)
	return &VaultLeaderCommissionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VaultLeaderCommissionClient) UpdateOne(vlc *VaultLeaderCommission) *VaultLeaderCommissionUpdateOne {
	mutation := newVaultLeaderCommissionMutation(c.config, OpUpdateOne, withVaultLeaderCommission(vlc))
	return &VaultLeaderCommissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *VaultLeaderCommissionClient) UpdateOneID(id int) *VaultLeaderCommissionUpdateOne {
	mutation := newVaultLeaderCommissionMutation(c.config, OpUpdateOne, withVaultLeaderCommissionID(id))
	return &VaultLeaderCommissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for VaultLeaderCommission.
func (c *VaultLeaderCommissionClient) Delete() *VaultLeaderCommissionDelete {
	mutation := newVaultLeaderCommissionMutation(c.config, OpDelete)
	return &VaultLeaderCommissionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *VaultLeaderCommissionClient) DeleteOne(vlc *VaultLeaderCommission) *VaultLeaderCommissionDeleteOne {
	return c.DeleteOneID(vlc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *VaultLeaderCommissionClient) DeleteOneID(id int) *VaultLeaderCommissionDeleteOne {
	builder := c.Delete().Where(vaultleadercommission.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &VaultLeaderCommissionDeleteOne{builder}
}

// Query returns a query builder for VaultLeaderCommission.
func (c *VaultLeaderCommissionClient) Query() *VaultLeaderCommissionQuery {
	return &VaultLeaderCommissionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeVaultLeaderCommission},
		inters: c.Interceptors(),
	}
}

// Get returns a VaultLeaderCommission entity by its id.
func (c *VaultLeaderCommissionClient) Get(ctx context.Context, id int) (*VaultLeaderCommission, error) {
	return c.Query().Where(vaultleadercommission.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *VaultLeaderCommissionClient) GetX(ctx context.Context, id int) *VaultLeaderCommission {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *VaultLeaderCommissionClient) Hooks() []Hook {
	return c.hooks.VaultLeaderCommission
}

// Interceptors returns the client interceptors.
func (c *VaultLeaderCommissionClient) Interceptors() []Interceptor {
	return c.inters.VaultLeaderCommission
}

func (c *VaultLeaderCommissionClient) mutate(ctx context.Context, m *VaultLeaderCommissionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&VaultLeaderCommissionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&VaultLeaderCommissionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&VaultLeaderCommissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&VaultLeaderCommissionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown VaultLeaderCommission mutation op: %q", m.Op())
	}
}

// VaultWithdrawalClient is a client for the VaultWithdrawal schema.
type VaultWithdrawalClient struct {
	config
}

// NewVaultWithdrawalClient returns a client for the VaultWithdrawal from the given config.
func NewVaultWithdrawalClient(c config) *VaultWithdrawalClient {
	return &VaultWithdrawalClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `vaultwithdrawal.Hooks(f(g(h())))`.
func (c *VaultWithdrawalClient) Use(hooks ...Hook) {
	c.hooks.VaultWithdrawal = append(c.hooks.VaultWithdrawal, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `vaultwithdrawal.Intercept(f(g(h())))`.
func (c *VaultWithdrawalClient) Intercept(interceptors ...Interceptor) {
	c.inters.VaultWithdrawal = append(c.inters.VaultWithdrawal, interceptors...)
}

// Create returns a builder for creating a VaultWithdrawal entity.
func (c *VaultWithdrawalClient) Create() *VaultWithdrawalCreate {
	mutation := newVaultWithdrawalMutation(c.config, OpCreate)
	return &VaultWithdrawalCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of VaultWithdrawal entities.
func (c *VaultWithdrawalClient) CreateBulk(builders ...*VaultWithdrawalCreate) *VaultWithdrawalCreateBulk {
	return &VaultWithdrawalCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *VaultWithdrawalClient) MapCreateBulk(slice any, setFunc func(*VaultWithdrawalCreate, int)) *VaultWithdrawalCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &VaultWithdrawalCreateBulk{err: fmt.Errorf("calling to VaultWithdrawalClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*VaultWithdrawalCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &VaultWithdrawalCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for VaultWithdrawal.
func (c *VaultWithdrawalClient) Update() *VaultWithdrawalUpdate {
	mutation := newVaultWithdrawalMutation(c.config, OpUpdate)
	return &VaultWithdrawalUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VaultWithdrawalClient) UpdateOne(vw *VaultWithdrawal) *VaultWithdrawalUpdateOne {
	mutation := newVaultWithdrawalMutation(c.config, OpUpdateOne, withVaultWithdrawal(vw))
	return &VaultWithdrawalUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *VaultWithdrawalClient) UpdateOneID(id int) *VaultWithdrawalUpdateOne {
	mutation := newVaultWithdrawalMutation(c.config, OpUpdateOne, withVaultWithdrawalID(id))
	return &VaultWithdrawalUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for VaultWithdrawal.
func (c *VaultWithdrawalClient) Delete() *VaultWithdrawalDelete {
	mutation := newVaultWithdrawalMutation(c.config, OpDelete)
	return &VaultWithdrawalDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *VaultWithdrawalClient) DeleteOne(vw *VaultWithdrawal) *VaultWithdrawalDeleteOne {
	return c.DeleteOneID(vw.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *VaultWithdrawalClient) DeleteOneID(id int) *VaultWithdrawalDeleteOne {
	builder := c.Delete().Where(vaultwithdrawal.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &VaultWithdrawalDeleteOne{builder}
}

// Query returns a query builder for VaultWithdrawal.
func (c *VaultWithdrawalClient) Query() *VaultWithdrawalQuery {
	return &VaultWithdrawalQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeVaultWithdrawal},
		inters: c.Interceptors(),
	}
}

// Get returns a VaultWithdrawal entity by its id.
func (c *VaultWithdrawalClient) Get(ctx context.Context, id int) (*VaultWithdrawal, error) {
	return c.Query().Where(vaultwithdrawal.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *VaultWithdrawalClient) GetX(ctx context.Context, id int) *VaultWithdrawal {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *VaultWithdrawalClient) Hooks() []Hook {
	return c.hooks.VaultWithdrawal
}

// Interceptors returns the client interceptors.
func (c *VaultWithdrawalClient) Interceptors() []Interceptor {
	return c.inters.VaultWithdrawal
}

func (c *VaultWithdrawalClient) mutate(ctx context.Context, m *VaultWithdrawalMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&VaultWithdrawalCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&VaultWithdrawalUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&VaultWithdrawalUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&VaultWithdrawalDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown VaultWithdrawal mutation op: %q", m.Op())
	}
}

// WithdrawClient is a client for the Withdraw schema.
type WithdrawClient struct {
	config
}

// NewWithdrawClient returns a client for the Withdraw from the given config.
func NewWithdrawClient(c config) *WithdrawClient {
	return &WithdrawClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `withdraw.Hooks(f(g(h())))`.
func (c *WithdrawClient) Use(hooks ...Hook) {
	c.hooks.Withdraw = append(c.hooks.Withdraw, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `withdraw.Intercept(f(g(h())))`.
func (c *WithdrawClient) Intercept(interceptors ...Interceptor) {
	c.inters.Withdraw = append(c.inters.Withdraw, interceptors...)
}

// Create returns a builder for creating a Withdraw entity.
func (c *WithdrawClient) Create() *WithdrawCreate {
	mutation := newWithdrawMutation(c.config, OpCreate)
	return &WithdrawCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Withdraw entities.
func (c *WithdrawClient) CreateBulk(builders ...*WithdrawCreate) *WithdrawCreateBulk {
	return &WithdrawCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *WithdrawClient) MapCreateBulk(slice any, setFunc func(*WithdrawCreate, int)) *WithdrawCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &WithdrawCreateBulk{err: fmt.Errorf("calling to WithdrawClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*WithdrawCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &WithdrawCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Withdraw.
func (c *WithdrawClient) Update() *WithdrawUpdate {
	mutation := newWithdrawMutation(c.config, OpUpdate)
	return &WithdrawUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WithdrawClient) UpdateOne(w *Withdraw) *WithdrawUpdateOne {
	mutation := newWithdrawMutation(c.config, OpUpdateOne, withWithdraw(w))
	return &WithdrawUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WithdrawClient) UpdateOneID(id int) *WithdrawUpdateOne {
	mutation := newWithdrawMutation(c.config, OpUpdateOne, withWithdrawID(id))
	return &WithdrawUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Withdraw.
func (c *WithdrawClient) Delete() *WithdrawDelete {
	mutation := newWithdrawMutation(c.config, OpDelete)
	return &WithdrawDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WithdrawClient) DeleteOne(w *Withdraw) *WithdrawDeleteOne {
	return c.DeleteOneID(w.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WithdrawClient) DeleteOneID(id int) *WithdrawDeleteOne {
	builder := c.Delete().Where(withdraw.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WithdrawDeleteOne{builder}
}

// Query returns a query builder for Withdraw.
func (c *WithdrawClient) Query() *WithdrawQuery {
	return &WithdrawQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeWithdraw},
		inters: c.Interceptors(),
	}
}

// Get returns a Withdraw entity by its id.
func (c *WithdrawClient) Get(ctx context.Context, id int) (*Withdraw, error) {
	return c.Query().Where(withdraw.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WithdrawClient) GetX(ctx context.Context, id int) *Withdraw {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *WithdrawClient) Hooks() []Hook {
	return c.hooks.Withdraw
}

// Interceptors returns the client interceptors.
func (c *WithdrawClient) Interceptors() []Interceptor {
	return c.inters.Withdraw
}

func (c *WithdrawClient) mutate(ctx context.Context, m *WithdrawMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WithdrawCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WithdrawUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WithdrawUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WithdrawDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Withdraw mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		Delegate, DelegatorReward, Fill, Funding, HyperunitOperation, InternalTransfer,
		RewardsClaim, SpotGenesis, SpotTransfer, TwapSliceFill, VaultDelta,
		VaultLeaderCommission, VaultWithdrawal, Withdraw []ent.Hook
	}
	inters struct {
		Delegate, DelegatorReward, Fill, Funding, HyperunitOperation, InternalTransfer,
		RewardsClaim, SpotGenesis, SpotTransfer, TwapSliceFill, VaultDelta,
		VaultLeaderCommission, VaultWithdrawal, Withdraw []ent.Interceptor
	}
)
